---
title: "Module Struct"
---

When developing runtime in Substrate, you need to declare a `Module` struct for your runtime module. This `Module` struct wraps a set of useful functions and implementations, either written by you or generated by the macros in Substrate. 

There are a few code snippets in following sections to show parts of `Module` struct implementations. If you are interested in what's fully expanded code look like for your module, try using [cargo-expand](https://github.com/dtolnay/cargo-expand) by following its instructions.

## The Definition of  Module Struct

Here is template runtime module provided by the node-template, it contains following code along with `decl_module!` macro:

```rust
decl_module! {
    /// The module declaration.
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        // Initializing events
        fn deposit_event<T>() = default;
        
        // Just a dummy entry point.
        pub fn do_something(origin, something: u32) -> Result {
            let who = ensure_signed(origin)?; 
            <Something<T>>::put(something);
            Self::deposit_event(RawEvent::SomethingStored(something, who));
            Ok(())
        }
    }
}
```

Let's look at the code that shows the definition of `Module` struct after expanded. It has a type parameter `T` which bounds to the module's configuration `Trait`. [PhantomData](https://doc.rust-lang.org/beta/std/marker/struct.PhantomData.html) is used to indicate what type of data our `Module` struct is "tied" to, but not found in our struct.

```rust
#[cfg(feature = "std")]
#[structural_match]
#[rustc_copy_clone_marker]
pub struct Module<T: Trait>(::std::marker::PhantomData<(T)>);
```

> *Notes:*
>
> * The attribute `#[cfg(feature = "std")]` tells the Rust compiler to only compile our struct when using along with the Rust standard library.
> * [`structural_match`](https://github.com/rust-lang/rfcs/pull/1445) is used to indicates that instances of the `Module` struct can be used within patterns.
> * `rustc_copy_clone_marker` indicates the `Module` struct is able to be either copied or cloned.

## Functions and Implementations

### Dispatchable Functions

Dispatchable functions are written by runtime developers and maintain the logic around how to manipulate the blockchain state. Here we only have one function named `do_something` in template runtime module, the expanded code is nearly same with original code except the added `origin` type signature.

```rust
impl<T: Trait> Module<T> {
    pub fn do_something(origin: T::Origin, something: u32) -> Result {
        let who = ensure_signed(origin)?;
        <Something<T>>::put(something);
        Self::deposit_event(RawEvent::SomethingStored(something, who));
        Ok(())
    }
}
```

`Module` struct implements the `Callable` trait in `srml-support` by specifying the associate type to be the module's `Call` enum. Above dispatchable functions will be exposed through this enum, go to its own page for more details about [`Call` enum]((runtime/types/call-enum.md)).

```rust
impl<T: Trait> ::srml_support::dispatch::Callable for Module<T> {
    type Call = Call<T>;
}
```

There is also a `dispatch` function that redirect the request to the module's `Call` enum:

```rust
impl<T: Trait> Module<T> {
    #[doc(hidden)]
    pub fn dispatch<D: ::srml_support::dispatch::Dispatchable<Trait=T>>(
        d: D,
        origin: D::Origin,
    ) -> ::srml_support::dispatch::Result {
        d.dispatch(origin)
    }
}
```

### Implementations for Storage

The input codes for the `decl_storage!` procedure macro in template module are:

```rust
/// This module's storage items.
decl_storage! {
    trait Store for Module<T: Trait> as TemplateModule {
        // Just a dummy storage item. 
        // Here we are declaring a StorageValue, `Something` as a Option<u32>
        // `get(something)` is the default getter which returns either the stored `u32` or `None` if nothing stored
        Something get(something): Option<u32>;
    }
}
```

After expanded, we'll see a `Store` implementation for `Module` struct. The `Store` trait here is an abstract layer that places all the associate types for module's available storage items. `Module` struct implements this trait by specifying the concrete types like `Something<T>` struct.

```rust
trait Store {
    type Something;
}

struct Something<T: Trait>(
    self::sr_api_hidden_includes_decl_storage::hidden_include::storage::generator::PhantomData<
        (T),
    >,
);

impl<T: Trait> Store for Module<T> {
    type Something = Something<T>;
}
```

The `Module` struct also implements the default getter functions for storage items and the query for storage metadata. Go to [Metadata of Your Module](#metadata-of-your-module) section to give a glimpse at details. 

### Deposit Event in Module

Remember the `deposit_event` function defined in the `decl_module!` macro? It will call the `deposit_event` function in `srml-system` runtime module to deposit an event into block's event record.

```rust
impl<T: Trait> Module<T> {
    fn deposit_event(event: Event<T>) {
        <system::Module<T>>::deposit_event(<T as Trait>::from(event).into());
    }
}
```

Refer to [Event Enum](runtime/types/event-enum.md) for more knowledge around events in Substrate.

### Utilities for Block Execution

There is three privileged functions that can be define in runtime modules:

1. `on_initialize` function lets you express what should happen for your module when the block is beginning (right before the first extrinsic is applied).
2. `on_finalize` function lets you express what should happen for your module when the block is ending.
3. `offchain_worker` function allows you to perform long-running tasks that make validators generate extrinsics with the results of those long-running computations.

The `decl_module!` macro will generate default implementations if you didn't provide your own:

```rust
impl<T: Trait> ::srml_support::runtime_primitives::traits::OnInitialize<T::BlockNumber>
    for Module<T>
{}

impl<T: Trait> ::srml_support::runtime_primitives::traits::OnFinalize<T::BlockNumber>
    for Module<T>
{}

impl<T: Trait> ::srml_support::runtime_primitives::traits::OffchainWorker<T::BlockNumber>
    for Module<T>
{}
```

## Tuple of All The Modules

Your `Module` struct then comes along with other used SRML modules to form a tuple called `AllModules` which will be tied to the `Executive` struct in `srml-executive`. 

```rust
pub type System = system::Module<Runtime>;
pub type Timestamp = timestamp::Module<Runtime>;
pub type Consensus = consensus::Module<Runtime>;
pub type Aura = aura::Module<Runtime>;
pub type Indices = indices::Module<Runtime>;
pub type Balances = balances::Module<Runtime>;
pub type Sudo = sudo::Module<Runtime>;
pub type TemplateModule = template::Module<Runtime>;

type AllModules = (
    Timestamp,
    Consensus,
    Aura,
    Indices,
    Balances,
    Sudo,
    TemplateModule,
);

/// Executive: handles dispatch to the various modules.
pub type Executive = executive::Executive<Runtime, Block, Context, Balances, AllModules>;
```

`Executive` struct provides implementation to handle block execution, our tuple will be used during applying extrinsics. Let me stop here and leave remaining mystery for you to explore.

## Metadata of Your Module

`Module` struct provides query functions for metadata of module's dispatchable functions and storage, the metadata for `Event` enum is actually in its own implementation. The following json shows the metadata of our template runtime module. Go to [this page](TODO) for more details around Substrate runtime metadata.

```json
{
    "modules":[
        {
            "name":"template",
            "prefix":"TemplateModule",
            "storage":[
                {
                    "name":"Something",
                    "modifier":"Optional",
                    "type":{
                        "PlainType":"u32"
                    },
                    "fallback":"0x00",
                    "documentation":[

                    ]
                }
            ],
            "calls":[
                {
                    "name":"do_something",
                    "args":[
                        {
                            "name":"something",
                            "type":"u32"
                        }
                    ],
                    "documentation":[

                    ]
                }
            ],
            "events":[
                {
                    "name":"SomethingStored",
                    "args":[
                        "u32",
                        "AccountId"
                    ],
                    "documentation":[

                    ]
                }
            ]
        }
    ]
}
```
